МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмної інженерії»







ЗВІТ
З Практичної роботи № 1
з дисципліни
«Архітектура програмного забезпечення»






Виконав
ст. гр. ПЗПІ-22-8
Ставицький Олександр
Перевірив
ст. викладач каф. ПІ
Сокорчук І. П.


Харків 2025
1 ІСТОРІЯ ЗМІН

	У цьому розділі відображено історію внесених змін до звіту, що наведено у табл. 1.

	Таблиця 1 – Історія змін
№
Дата
Версія
Опис змін
Автор
1
08.04.2025
0.1
Створено розділ «Завдання»
Ставицький Олександр
2
08.04.2025
0.1
Створено розділ «Опис виконаної роботи»
Ставицький Олександр
3
08.04.2025
0.1
Створено розділ «Висновки»
Ставицький Олександр
4
09.04.2025
0.1
Додано слайди презентації в додатку Б
Ставицький Олександр
5
09.04.2025
0.1
Додано програмний код в додатку В
Ставицький Олександр
6
10.04.2025
0.1
Додано посилання на відео  в додатку А та створено хронологічний опис
Ставицький Олександр
2 ЗАВДАННЯ

	У рамках виконання цієї практичної роботи треба було вивчити та дослідити патерн проєктування Mediator (Посередник). Це передбачало детальне вивчення його структури та основних принципів функціонування. Необхідно було опрацювати теоретичні основи цього патерну та проаналізувати його ключові складові. 
     Також, необхідно було проаналізувати використання патерну в реальних програмних рішеннях та визначити його переваги та недоліки.

3 ОПИС ВИКОНАНОЇ РОБОТИ

     У процесі виконання роботи було досліджено патерн проєктування Mediator (Посередник).

3.1 Суть патерну Mediator

     Mediator — це поведінковий патерн проектування, що дає змогу зменшити зв’язаність великої кількості класів між собою, завдяки переміщенню цих зв’язків до одного класу-посередника.
     
3.2 Структура патерну

	Структура даного патерну складається з таких компонентів:
     Компоненти — це різнорідні об’єкти, що містять бізнес-логіку програми. Кожен компонент має посилання на об’єкт посередника, але працює з ним тільки через абстрактний інтерфейс посередників. 
     Посередник — визначає інтерфейс для обміну інформацією з компонентами.
     Конкретний Посередник — реалізує логіку координації взаємодії між компонентами.
     



3.3 Принцип роботи патерну
     
     Якщо в компоненті відбувається подія, він повинен повідомити свого посередника.
     Посередник сам вирішить, чи стосується подія інших компонентів, і чи треба їх сповістити. 
     При цьому компонент-відправник не знає, хто обробить його запит, а компонент-одержувач не знає, хто його надіслав.

3.4 Застосовність

	Патерн Mediator слід використовувати в таких випадках:
- Коли вам складно змінювати деякі класи через те, що вони мають величезну кількість хаотичних зв’язків з іншими класами.
- Коли ви не можете повторно використовувати клас, оскільки він залежить від безлічі інших класів.
- Коли вам доводиться створювати багато підкласів компонентів, щоб використовувати одні й ті самі компоненти в різних контекстах.

3.5 Переваги та недоліки

	Переваги:
- Усуває залежності між компонентами, дозволяючи використовувати їх повторно.
- Спрощує взаємодію між компонентами.
- Централізує керування в одному місці.
	Недоліки:
- Посередник може сильно «роздутися» і стати надто складним, якщо логіка взаємодії велика.

3.6 Аналогія з життя

     Пілоти літаків, що сідають або злітають, не спілкуються з іншими пілотами безпосередньо. Замість цього вони зв’язуються з диспетчером, який координує політ кількох літаків одночасно. Без диспетчера пілотам доводилося б увесь час бути напоготові і стежити самостійно за всіма літаками навколо.

3.7 Реалізація патерну на С#

	Було розроблено приклад реалізації патерну Mediator на мові C# (додаток B), який демонструє систему взаємодії між окремими компонентами без прямого зв’язку між ними.
     У цьому прикладі реалізовано два компоненти — ComponentA та ComponentB, які виконують певні дії. Замість того, щоб напряму викликати методи один одного, вони надсилають повідомлення об’єкту-посереднику (ConcreteMediator), який приймає рішення, як обробити подію.
     
     4 ВИСНОВКИ
     У ході виконання практичної роботи було детально вивчено патерн проєктування Mediator (Посередник). Завдяки цьому патерну вдалося зрозуміти, як можна зменшити залежність між класами в програмній системі та централізувати логіку їхньої взаємодії.
     Було проаналізовано структуру патерну, принцип його роботи, сфери застосування, а також основні переваги та недоліки. Реалізація патерну на мові C# дозволила закріпити отримані теоретичні знання на практиці.


ДОДАТОК А

	Посилання на відеозапис доповіді та хронологічний опис.
     Відеозапис доповіді на YouTube: https://youtu.be/hC188zsZCqI 
     Хронологічний опис:
     00:00 - титульний слайд 
     00:25 - сутність патерну 
     00:45 - проблематика 
     01:28 - рішення 
     01:50 - структура 
     02:57 - коли слід застосовувати 
     03:24 - переваги та недоліки 
     03:58 - аналог з життя 
     04:28 - приклад коду 
     05:01 - дякую за увагу


ДОДАТОК Б

     Слайди презентації доповіді
     

Рис. Б1 – Титульний слайд


Рис. Б2 – Сутність патерну

Рис. Б3 – Проблематика


Рис. Б4 – Рішення


Рис. Б5 – Структура


Рис. Б6 – Коли слід застосовувати


Рис. Б7 – Переваги та недоліки


Рис. Б8 – Аналог з життя


Рис. Б9 – Приклад коду


Рис. Б10 – Дякую за увагу

ДОДАТОК В

	Програмний код

public interface IMediator
{
    void Notify(Component sender, string eventName);
}
public class Component
{
    protected IMediator mediator;

    public void SetMediator(IMediator mediator)
    {
        this.mediator = mediator;
    }
}
public class ComponentA : Component
{
    public void DoA()
    {
        Console.WriteLine("ComponentA виконує A");
        mediator.Notify(this, "A");
    }
}

public class ComponentB : Component
{
    public void DoB()
    {
        Console.WriteLine("ComponentB виконує B");
        mediator.Notify(this, "B");
    }
}
public class ConcreteMediator : IMediator
{
    private ComponentA componentA;
    private ComponentB componentB;

    public ConcreteMediator(ComponentA a, ComponentB b)
    {
        componentA = a;
        componentB = b;

        componentA.SetMediator(this);
        componentB.SetMediator(this);
    }

    public void Notify(Component sender, string eventName)
    {
        if (eventName == "A")
        {
            Console.WriteLine("Посередник реагує на A і викликає B");
            componentB.DoB();
        }
        else if (eventName == "B")
        {
            Console.WriteLine("Посередник реагує на B і викликає A");
            componentA.DoA();
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        ComponentA a = new ComponentA();
        ComponentB b = new ComponentB();

        ConcreteMediator mediator = new ConcreteMediator(a, b);

        a.DoA();
        Console.WriteLine("-----");
        b.DoB();
    }
}
4


